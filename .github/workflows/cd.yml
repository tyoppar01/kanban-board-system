name: CD - EC2 Deployment

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production

env:
  IMAGE_TAG: ${{ github.sha }}

jobs:
  deploy:
    name: EC2 Deployment
    runs-on: ubuntu-latest
    # Only deploy if CI passed and triggered from main branch
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event.workflow_run.conclusion == 'success' && 
       github.event.workflow_run.head_branch == 'main')
    
    # secrets environment variables
    environment:
      name: env-prod
    
    steps:
      # 1) run checkout src code
      - name: Checkout code
        uses: actions/checkout@v4

      # 2) initialization .env file and insert necessary secret variables
      - name: Create Environmental Variables
        run: |
          cat > .env.production << EOF
          NODE_ENV=production
          SERVER_PORT=8080
          NEXT_PUBLIC_API_URL=http://${{ secrets.EC2_HOST }}:8080
          NEXT_PUBLIC_GRAPHQL_URL=http://${{ secrets.EC2_HOST }}:8080/graphql
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgresql:5432/${{ secrets.POSTGRES_DB }}
          EOF
          echo "‚úÖ Production .env file created"
          
          # Export for docker build
          export NEXT_PUBLIC_API_URL=http://${{ secrets.EC2_HOST }}:8080
          export NEXT_PUBLIC_GRAPHQL_URL=http://${{ secrets.EC2_HOST }}:8080/graphql

      # 3) build production images
      - name: Build Production Images
        env:
          NEXT_PUBLIC_API_URL: http://${{ secrets.EC2_HOST }}:8080
          NEXT_PUBLIC_GRAPHQL_URL: http://${{ secrets.EC2_HOST }}:8080/graphql
        run: |
          echo "üî® Building production images..."
          docker build --target production -f server/Dockerfile -t kanban-server:latest .
          docker build --target production -f client/Dockerfile \
            --build-arg NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL} \
            --build-arg NEXT_PUBLIC_GRAPHQL_URL=${NEXT_PUBLIC_GRAPHQL_URL} \
            -t kanban-client:latest .
          docker save kanban-server:latest > server-image.tar
          docker save kanban-client:latest > client-image.tar
          echo "‚úÖ Production images built and saved"

      # 4) setup SSH connection (without AWS credentials)
      - name: Setup SSH
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_HOST_CLIENT: ${{ secrets.EC2_HOST_CLIENT }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          mkdir -p ~/.ssh
          echo "$EC2_SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts
          ssh-keyscan -H $EC2_HOST_CLIENT >> ~/.ssh/known_hosts
          ssh -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST} "mkdir -p /home/${EC2_USER}/kanban-board-system"
          ssh -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST_CLIENT} "mkdir -p /home/${EC2_USER}/kanban-board-system"

      # 5) copy files to EC2 instances
      - name: Copy files to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_HOST_CLIENT: ${{ secrets.EC2_HOST_CLIENT }}
        run: |        

          # Server Instance
          echo "üì¶ Copying files to Server EC2 ..."
          scp -i ~/.ssh/deploy_key server-image.tar ${EC2_USER}@${EC2_HOST}:/tmp/
          scp -i ~/.ssh/deploy_key client-image.tar ${EC2_USER}@${EC2_HOST}:/tmp/
          scp -i ~/.ssh/deploy_key docker-compose.yml ${EC2_USER}@${EC2_HOST}:/home/${EC2_USER}/kanban-board-system/
          echo "üì¶ Copying env file to Server EC2 ..."
          scp -i ~/.ssh/deploy_key .env.production ${EC2_USER}@${EC2_HOST}:/home/${EC2_USER}/kanban-board-system/.env
          
          # Client Instance
          echo "üì¶ Copying files to Client EC2 ..."
          scp -i ~/.ssh/deploy_key server-image.tar ${EC2_USER}@${EC2_HOST_CLIENT}:/tmp/
          scp -i ~/.ssh/deploy_key client-image.tar ${EC2_USER}@${EC2_HOST_CLIENT}:/tmp/
          scp -i ~/.ssh/deploy_key docker-compose.yml ${EC2_USER}@${EC2_HOST_CLIENT}:/home/${EC2_USER}/kanban-board-system/
          echo "üì¶ Copying env file to Client EC2 ..."
          scp -i ~/.ssh/deploy_key .env.production ${EC2_USER}@${EC2_HOST_CLIENT}:/home/${EC2_USER}/kanban-board-system/.env
          
          echo "‚úÖ Files copied to both instances"

      # 6) deploy in EC2 instances 
      - name: Deploy App to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_HOST_CLIENT: ${{ secrets.EC2_HOST_CLIENT }}
          EC2_USER: ${{ secrets.EC2_USER }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          echo "üöÄ Deploy Process EC2 SERVER"
          ssh -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST} << EOF
            set -e
                        
            # Navigate to project directory
            cd /home/${EC2_USER}/kanban-board-system
            
            echo "üì• Loading Docker images..."
            docker load < /tmp/server-image.tar
            docker load < /tmp/client-image.tar
            
            # Backup current images (for rollback)
            echo "üíæ Creating backup tags..."
            docker tag kanban-server:latest kanban-server:previous 2>/dev/null || true
            docker tag kanban-client:latest kanban-client:previous 2>/dev/null || true
            
            # Stop and start containers with docker-compose
            echo "üîÑ Restarting containers..."
            docker-compose down --timeout 30 || true
            docker-compose up -d
            
            # Clean up temp files
            rm -f /tmp/server-image.tar /tmp/client-image.tar
            echo "‚úÖ Server deployment complete!"
          EOF
          
          echo "üöÄ Deploy Process EC2 CLIENT"
          ssh -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST_CLIENT} << EOF
            set -e
            cd /home/${EC2_USER}/kanban-board-system
            
            echo "üì• Loading Docker images..."
            docker load < /tmp/server-image.tar
            docker load < /tmp/client-image.tar
            
            echo "üíæ Creating backup tags..."
            docker tag kanban-server:latest kanban-server:previous 2>/dev/null || true
            docker tag kanban-client:latest kanban-client:previous 2>/dev/null || true
            
            echo "üîÑ Restarting containers..."
            docker-compose down --timeout 30 || true
            docker-compose up -d client
            
            rm -f /tmp/server-image.tar /tmp/client-image.tar
            echo "‚úÖ Client deployment complete!"
          EOF

      # 7) WAIT TIME to start server
      - name: Await Service Initialization
        run: |
          echo "‚è≥ Waiting for services to initialize..."
          sleep 15

      # 8) Health Check
      - name: Health Check
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_HOST_CLIENT: ${{ secrets.EC2_HOST_CLIENT }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          ssh -T -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST} << EOF
            set -e
            
            echo "üè• Running health checks..."
            cd /home/${EC2_USER}/kanban-board-system
            echo "üìä Container status:"
            docker-compose ps
            sleep 5
        
            if curl -f -s http://localhost:8080/ > /dev/null; then
              echo "‚úÖ Server (port 8080) is healthy"
            else
              echo "‚ùå Server health check failed"
              docker-compose logs --tail=50 server
              exit 1
            fi
            
            # Check database health
            if docker-compose exec -T postgresql pg_isready -U kanban -d kanban_db > /dev/null; then
              echo "‚úÖ Database is healthy"
            else
              echo "‚ö†Ô∏è  Database health check warning"
            fi
          EOF
        
          ssh -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST_CLIENT} << EOF
            set -e
            cd /home/${EC2_USER}/kanban-board-system
            
            echo "üìä Container status:"
            docker-compose ps
            
            sleep 5
            
            if curl -f -s http://localhost:3000/ > /dev/null; then
              echo "‚úÖ Client (port 3000) is healthy"
            else
              echo "‚ùå Client health check failed"
              docker-compose logs --tail=50 client
              exit 1
            fi
          EOF
          
          echo "üéâ All health checks passed!"

      # 9) Cleanup
      - name: Cleanup Images
        if: success()
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_HOST_CLIENT: ${{ secrets.EC2_HOST_CLIENT }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          echo "üßπ Cleaning up old Docker images..."
          
          ssh -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST} << EOF
            docker image prune -f
          EOF
          
          ssh -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST_CLIENT} << EOF
            docker image prune -f
            echo "‚ú® Cleanup complete"
          EOF
          
          echo "‚ú® Cleanup complete"

      # 10) Devployment Results
      - name: Deployment Summary
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "üéä Deployment successful!"
            echo "üìç Application URL: http://${{ secrets.EC2_HOST_CLIENT }}:3000"
            echo "üìç GraphQL API: http://${{ secrets.EC2_HOST }}:8080/graphql"
            echo "üè∑Ô∏è  Version: ${{ github.sha }}"
          else
            echo "üí• Deployment failed!"
            echo "Check logs above for details"
          fi

  rollback:
    name: Rollback
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: deploy
    
    steps:
      - name: Setup SSH
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_HOST_CLIENT: ${{ secrets.EC2_HOST_CLIENT }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          mkdir -p ~/.ssh
          echo "$EC2_SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts
          ssh-keyscan -H $EC2_HOST_CLIENT >> ~/.ssh/known_hosts

      - name: Rollback to previous version
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_HOST_CLIENT: ${{ secrets.EC2_HOST_CLIENT }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: | 
          echo "‚è™ Rolling back Server instance..."
          ssh -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST} << EOF
            echo "‚è™ Rolling back to previous version..."
            cd /home/${EC2_USER}/kanban-board-system
            
            # Tag previous images as latest
            docker tag kanban-server:previous kanban-server:latest
            docker tag kanban-client:previous kanban-client:latest
            
            # Restart containers
            docker-compose down
            docker-compose up -d
            
            echo "‚úÖ Server rollback complete"
          EOF
          
          echo "‚è™ Rolling back Client instance..."
          ssh -i ~/.ssh/deploy_key ${EC2_USER}@${EC2_HOST_CLIENT} << EOF
            echo "‚è™ Rolling back to previous version..."
            cd /home/${EC2_USER}/kanban-board-system
            
            # Tag previous images as latest
            docker tag kanban-server:previous kanban-server:latest
            docker tag kanban-client:previous kanban-client:latest
            
            # Restart containers
            docker-compose down
            docker-compose up -d client
            
            echo "‚úÖ Client rollback complete"
          EOF
